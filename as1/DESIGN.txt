When the user inputs a command, the command is stored inside an array of strings. Then the program will parse the array by using a for loop to cycle through the array. In each cycle, exists if statements that will compare certain commands and if they match, the if statement will set the appropriate flags. The flags are stored in boolean variables for example if one of the commands contained a ">", the if statement will set the boolean flag to true and store the following argument which is a file to a pointer of char type. This step is kind of like collecting information about the command. Once you have all the information, you need to create a child process using fork system call. Inside the child process, is another group of if statements that will check all the boolean flags. If all the flags are false, the system call execvp will exectute the command. If a flag is true, it will prepare the necessary things needed before the command is executed. There exists three commands that need to be prepared before they are exectuted such as redirecting output to a file, redirecting input from a file, and output that is piped to the input of another. For example, lets say the command was ls -l > somefile. First a file needs to be created using the open system call. In addition, you need to handle the output of ls -l and direct it to the file. By default, ls -l will print its contents to the STDOUT stream. In order to change the output destination, you need to change the contents of where the STDOUT file descriptor is located to the file descriptor that was created by the open system call. To do this you will use the close system call to empty the location of where STDOUT was stored and use the dup system call to replace it with the file descriptor of the file created. As a result, the command is ready to be executed by using the system call, execvp. If there was a command whose input was redirected from a file, the process of preparing the command is very similar to redirecting the output to a file. THe only difference is you instead of replacing the file descriptor of STDOUT you replace the file descriptor of STDIN. Last but not least, there exist a command whose output is piped to the input of another command. For example, lets say our command is ls -l | grep file. There exists two commands but execvp can only execute one command at a time and we need the first command to be executed before the second so to solve this problem we need to use recursion and system call pipe. Use recursion to break the command into two pieces so that during the first call of the function, ls -l is executed and on the second the grep file commmand is called but how do we send the output of ls -l to be used as input for grep file to be exectuted. The answer is using the system call pipe with an int array of two integers 0 and 1. 0 represents where stuff enters the pipe and 1 represents stuff that leaves the pipe. Before ls -l is executed something needs to be done that is very similar to what was done for the redirection. Instead of replacing the file descriptor of STDOUT with a file created we replace it with the file descriptor of the first element of the  array. Just think of the array containing two file descriptors. Once ls -l is executed, the ouput is redirected to the input of the pipe and the reference to the pipe is passed when the function calls itself. In addition, the char array of strings containing your entire command wont be entirely passed into the next function call. Only the command grep file will be passed along with a flag that will allow the stuff passed through the pipe to be the input of grep file. But of course you need to replace the file descriptor of STDIN with the file descriptor of the pipe that was passed on previous call.